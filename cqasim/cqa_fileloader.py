#!/usr/bin/env python3
"""File loader for data files generated by cqa_simulator.py."""

import os
import numpy as np

from cqasim.cqa_defaults import CqaDefaults


class CqaFileLoader(CqaDefaults):
    """Load data of the CQA.

    Example use:
        # Initialize object
        fl = CqaFileLoader(paths=PATHS["runs"])
        # Update parameters in dictionary
        fl.par.update({
            "var_diameter": 0.75,
            "mean_diameter": 1.57,
        })
        # Load files with:
        dt = fl.files["data"]
        # Or:
        dt = fl.data
        # Print Info:
        fl.print_info(verbose=1)
    """

    def __init__(self, paths, par=None, ):
        """Initialize the SimulationFileLoader.

        Parameters:
            paths (Path or str): Base path to the simulation data directories.
            par (dict, optional): Dictionary of simulation parameters.
                                If provided, used to construct a nested folder
                                structure for file access. Otherwise a default
                                dictionary is used.
        """
        # Initialize super class
        super().__init__()
        self.paths = paths
        self._par = ObservableDict(par or self.default_par,
                                   callback=self._update_paths)
        self.base_path = None
        self.path = None
        self.files = {}
        self.name_list = []
        self.file_list = []

        self._update_paths()

    @property
    def par(self):
        """Automatically update Observable Dict."""
        return self._par

    def _update_paths(self):

        self.path = self.build_fp(self.paths)
        try:
            if self.path.exists():
                self.file_list = [f for f in os.listdir(self.path)
                                  if os.path.isfile(self.path / f)]
                self.name_list = [f.split("fieldM")[0][:-1]  # fieldM is 1. param
                                  for f in self.file_list]
                # Load data
                self.files = {name: np.load(self.path / f) for name, f
                              in zip(self.name_list, self.file_list)}
                # Auto-create attributes
                for key, dt in self.files.items():
                    setattr(self, key, dt)
        except KeyError:
            # TODO: give useful Error message, i.e. where the error occurs.
            print("Parameters are not complete or file structure is outdated.")
            # Parameters are not complete yet â€” skip path update
            print("--> skip path update")
            # pass

    def print_info(self, verbose=0):
        """Print detailed file info."""
        print(str(self.path))
        print(" -- Ex. file:", str(self.file_list[0]))
        if verbose > 0:
            print("")
            print(" -- All parameters: ", self.par)
            print(" -- All files in folder: ", self.name_list)

    def __str__(self):
        """Return a user-friendly description of the object."""
        return f"<SimulationFileLoader at {self.path}>"

    def __repr__(self):
        """Return a detailed, unambiguous representation of the object."""
        return (f"SimulationFileLoader(paths={self.paths!r}, "
                f"par={dict(self.par)!r}, "
                f"path={self.path!r}, "
                f"loaded_files={list(self.files.keys())})")


class ObservableDict(dict):
    """Create custom dictionary class to automatically trigger updates.

    (Because python doesn't notice updates in a plain dictionary.)
    """

    def __init__(self, *args, callback=None, **kwargs):
        super().__init__(*args, **kwargs)
        self._callback = callback

    def __setitem__(self, key, value):
        super().__setitem__(key, value)
        if self._callback:
            self._callback()

    def update(self, *args, **kwargs):
        super().update(*args, **kwargs)
        if self._callback:
            self._callback()
